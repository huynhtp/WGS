#!/usr/bin/env perl

# run-assembly: Perform standard assembly protocol operations on 454 pyrosequenced flowgram file(s)
# Author: Andrey Kislyuk (kislyuk@gatech.edu)

package PipelineRunner;
my ($VERSION) = ('$Id: $' =~ /,v\s+(\d+\S+)/o);

my $settings = {
	appname => 'cgpipeline',
};
my $stats;

use strict;
use FindBin;
use lib "$FindBin::RealBin/../lib";
$ENV{PATH} = "$FindBin::RealBin:".$ENV{PATH};
use AKUtils qw(logmsg);

use Getopt::Long;
use File::Temp ('tempdir');
#use File::Path qw(make_path remove_tree);
use File::Path;
use File::Spec;
use File::Copy;
use File::Basename;
use List::Util qw(min max sum shuffle);
use CGPipelineUtils;
use Data::Dumper;

$0 = fileparse($0);
local $SIG{'__DIE__'} = sub { my $e = $_[0]; $e =~ s/(at [^\s]+? line \d+\.$)/\nStopped $1/; die("$0: ".(caller(1))[3].": ".$e); };
sub logmsg {my $FH = $FSFind::LOG || *STDOUT; print $FH "$0: ".(caller(1))[3].": @_\n";}

exit(main());

sub main() {
	$settings = AKUtils::loadConfig($settings);

	# print out usage if no arguments are specified
	if(@ARGV<1){
	  print("	Usage: $0 input.sff [, input2.sff, ...] [-R reference1.mfa [-R reference2.mfa...]] [-C workdir] [-e expectedGenomeSize] [-d=forceDeNovo]
	-e expectedGenomeSize: in megabases 
	-d forceDeNovo: either T or F but is false by default (true if no reference specified)
    ");
	  exit;
	}
	
	my @cmd_options = ('ChangeDir=s', 'Reference=s@', 'keep', 'tempdir=s', 'output=s','expectedSize=i','deNovo=s');
	GetOptions($settings, @cmd_options) or die;

	# see if each reference file exists
	foreach my $file (@{$$settings{Reference}}){
	  $file = File::Spec->rel2abs($file);
	  die("Input or reference file $file not found") unless -f $file;
	}

  # separate input files into different chemistries
  my %input_file=separateInputFilesByChemistry(\@ARGV,$settings);
  my @chemistry=keys(%input_file);

	my($invoke_string,$params,@parametersToPass,@parametersToSkip,$assemblyDir,$tempDir,@finalAssemblyFilename);
	@parametersToPass=qw(keep expectedSize);
	# run DE NOVO if it's explicitly asked for, or if there are no references
	if($$settings{deNovo} eq 'T'||scalar(@{ $$settings{Reference} })<1){
    for my $chemistry(@chemistry){ # e.g. 454, illumina
      my $assemblyProgram="run_assembly_$chemistry.pl";
      my $input_file=$input_file{$chemistry};
      $tempDir=$$settings{tempdir}."/"."DENOVO"."/".$chemistry;
      my $outFilename="$tempDir/final.fna";
      push(@finalAssemblyFilename,$outFilename);
      mkpath($tempDir);
      $params=join(" ",@$input_file)." --tempdir $tempDir --output $outFilename ";
      $params.=parameterString(\@parametersToPass,$settings);
      $invoke_string="$assemblyProgram $params";
      logmsg "De novo assembly";
      system($invoke_string);
    }
	}
	# run assembly or assemblies for each REFERENCE, plus once for de novo if applicable
	foreach my $R (@{$$settings{Reference}}){
    die "Not set up for reference assembly yet";
    my $chemistry=""; ########
    my $assemblyProgram="run_assembly_$chemistry.pl";
	  $tempDir=$$settings{tempdir}."/".basename($R,qw(.fna .ffn .faa .fasta .seq .fa));
	  my $outFilename="$tempDir/final.fna";
	  push(@finalAssemblyFilename,$outFilename);
	  mkpath($tempDir);
	  # parameters for the assembly
	  $params=join(" ",@ARGV)." -R $R --tempdir $tempDir --output $outFilename ";
	  $params.=parameterString(\@parametersToPass,$settings);

	  # run the assembly with parameters
	  $invoke_string="$assemblyProgram $params";
	  logmsg "Reference assembly with $R";
	  system($invoke_string);
    }

	# Now that each assembly has been produced, find the best assembly.
	# Preferential treatment is given to the de novo assembly, so it goes first in the arguments list
	# Usage: $0 assembly1.fasta [,assembly2.fasta...] -output bestAssembly.fasta
	$invoke_string="run_assembly_chooseBest.pl ".join(" ",@finalAssemblyFilename)." --output $$settings{output}";
	logmsg $invoke_string;
	system($invoke_string);
  $invoke_string="run_assembly_metrics.pl $$settings{output}";
  logmsg $invoke_string;
  system($invoke_string);

	return 0;
}

# returns a string of parameters, for passing to another program.
# Opposite of GetOptions kind of
# parameters: $parametersToGet
#             $settings (Andrey's settings hash)
sub parameterString{
  my($parametersToGet,$settings)=@_;
  my($params);
  foreach my $param (@$parametersToGet){
	if($$settings{$param}){
	  $params.="--$param ";
	  my $value=$$settings{$param};
	  if($value ne '1'){
		if(ref($value) eq 'ARRAY'){
		  $value=join(" ",@$value);
		}
		$params.="'$value' ";
	  }
	}
  }
  return $params;
}

# see if there is a value in an array
# parameters: $array, $value
sub in_array{
   my ($arr,$search_for) = @_;
   my %items = map {$_ => 1} @$arr;
   return (exists($items{$search_for}))?1:0;
}

# make a hash of arrays of files, by chemistry type (e.g. $file{454}=>[input1.sff,input2.sff])
sub separateInputFilesByChemistry{
  my($input_file,$settings)=@_;
  my %file;
  for my $f(@$input_file){
    my $ext=$f;
    $ext=~s/^.+\.//;
    $ext=lc($ext); # lc saves on the cost of =~//i later
    if($ext=~/sff/){ # 454
      push(@{ $file{'454'} },$f);
    }
    elsif($ext=~/^(sff|fna|fasta|ffn|fa|mfa)$/){ # fasta
      push(@{ $file{'fasta'} },$f);
    }
    elsif($ext=~/^(fastq|fq)$/){
      push(@{ $file{'illumina'} },$f);
    }
    else{
      die "Could not determine the file type of $f or it is not supported. Cannot continue";
    }
  }
  return %file;
}

