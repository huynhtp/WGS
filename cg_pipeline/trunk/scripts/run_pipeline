#!/usr/bin/perl

# run_pipeline: wrapper script for CG-Pipeline
# Author: Lee Katz (lskatz@gatech.edu)
# Author: Jay Humphrey (jhumphrey6@gatech.edu)
# Author: Andrey Kislyuk (kislyuk@gatech.edu)

package PipelineRunner;
my ($VERSION) = ('$Id: $' =~ /,v\s+(\d+\S+)/o);

my $settings = {
  appname => 'cgpipeline',
};
my $stats;

use strict;
use FindBin;
use lib "$FindBin::RealBin/../lib";
$ENV{PATH} = "$FindBin::RealBin:".$ENV{PATH};
use AKUtils qw(logmsg);

use Getopt::Long;
use File::Temp ('tempdir');
use File::Path;# qw(make_path remove_tree);
use File::Path;
use File::Spec;
use File::Copy;
use File::Basename;
use List::Util qw(min max sum shuffle);
use CGPipelineUtils;
use Data::Dumper;
use Switch 'fallthrough';

my $WRAPPER_VERSION=0.2; # this is the wrapper version only.  Not the CP-Pipeline version.
my $verbose;

$0 = fileparse($0);
local $SIG{'__DIE__'} = sub { my $e = $_[0]; $e =~ s/(at [^\s]+? line \d+\.$)/\nStopped $1/; die("$0: ".(caller(1))[3].": ".$e); };
sub logmsg {my $FH = $FSFind::LOG || *STDOUT; print $FH "$0: ".(caller(1))[3].": @_\n";}

exit(main());
sub main(){
  $settings = AKUtils::loadConfig($settings);
  my $home=`pwd`;
    chomp($home);
  
  # get options
  my @cmd_options = ('help','deNovo=s','force','project=s','input=s@','tag_prefix=s','Reference=s','command=s','verbose=i');
  GetOptions($settings,@cmd_options) or die;
  $verbose=(defined($$settings{verbose}))?$$settings{verbose}:1;
  
  # if the user needs help, print out verbose help
  if($$settings{help}){
    print usage('v');
    exit;

  }
  # check out the arguments; see if it looks good or give defaults
  my $command=$ARGV[0]||$$settings{command}||die "Command not given\n".usage();
  $command=lc($command);
  my $project=$$settings{project}||die "Project not given\n". usage(); # project name
  my $tag_prefix=$$settings{tag_prefix}||$project; # prediction tag prefixes
  my $target=$$settings{input}; # SFF file


  # Avoid creating a project that already exists, unless forcing with -f
  if(-e $$settings{project}){
    if(!$$settings{force}){
      if($command eq 'create'||$command eq 'build'){
        print "Project $$settings{project} already exists; add -f to override.\n";
        die();
      }
    }
  }

  # based on the command, do a variety of things (create, assemble, predict, annotate or do everything which is "build")
  my $invoke_string;
  switch($command){
    # if build then go through every stage of the pipeline
    case (/build/){
      #print __LINE__."\n";
    }
    case (/build|create/){
      CGLog("$project/log/create.txt","CREATE START ".date());
      mkpath("$project/annotation","$project/log","$project/build/assembly","$project/build/prediction","$project/build/annotation");
      #`$invoke_string`;
      CGLog("$project/log/create.txt","CREATE END ".date());
      last if($command ne "build");
    }
    case (/build|assemble/){
      my $logfile="$project/log/assembly.txt";
      CGLog($logfile,"ASSEMBLY START ".date());
      foreach(@$target){
        if(! -e){
          die("Target file not found $_.\n".usage());
        }
      }
      my $refarg="";
      if($$settings{Reference}){
        my @reference=split(/\s+/,$$settings{Reference});
        foreach(@reference){
          $refarg.="-R $_ ";
        }
      }
      else{
        CGLog($logfile,"No reference genome provided.  Proceeding with the de novo assembly...\n",'append');
      }
      # loop through each sff file and see if it exists.  If so, make an argument.
      my $sffarg="";
      foreach(@{ $$settings{input} }){
        if(! -e){
          die("SFF file $_ does not exist.");
        }
        $sffarg.="$_ ";
      }
      $invoke_string="time run_assembly $sffarg --tempdir=$home/$project/build/assembly --keep $refarg --output $home/$project/assembly.fasta 2>&1 ";
      if($verbose>1){
        $invoke_string.="|tee --append $logfile";
      }
      else{
        $invoke_string.=">>$logfile";
      }
      CGLog($logfile,"COMMAND to assemble with ".scalar(@{ $$settings{input} })." SFF files\n  $invoke_string",'append');
      system($invoke_string);
      CGLog($logfile,'ASSEMBLY END '.date(),'append');
      $$settings{input}=""; # unset input for any possible future steps, because input was meant as an SFF in this case
      last if($command ne "build");
    }
    case (/build|predict/){
      my $logfile="$project/log/prediction.txt";
      CGLog($logfile,"PREDICTION START on project $project ".date());
      my $mfaArg="";
      foreach(@{ $$settings{input} }){
        if(! -e){
          die("Input FASTA file $_ does not exist.");
        }
        $mfaArg.="$_ ";
      }
      $mfaArg=$mfaArg||"$home/$project/assembly.fasta";
      $invoke_string="time run_prediction $mfaArg --tempdir=$home/$project/build/prediction --keep -o $home/$project/prediction.gb --strain_name=$project 2>&1 ";
      if($verbose>1){
        $invoke_string.="|tee --append $logfile";
      }
      else{
        $invoke_string.=">>$logfile";
      }
      CGLog($logfile,"COMMAND\n  $invoke_string",'append');
      system($invoke_string);
      CGLog($logfile,"PREDICTION END on project $project ".date(),'append');
      # It's not necessary to unset variables here like in assembly, because if build were the command, then everything is unset. 
      #   If predict is the command, then the wrapper will not continue.
      last if($command ne "build");
    }
    case (/build|annotate/){
      my $logfile="$project/log/annotation.txt";
      CGLog($logfile,"ANNOTATION START on $project ".date());
      my $gbArg="";
      foreach(@{ $$settings{input} }){
        if(! -e){
          die("Input FASTA file $_ does not exist.");
        }
        $gbArg.="$_ ";
      }
      $gbArg=$gbArg||"$home/$project/prediction.gb";
      $invoke_string="run_annotation $gbArg -tempdir=$home/$project/build/annotation --keep --outdir=$home/$project/annotation  2>&1 ";
      if($verbose>1){
        $invoke_string.="|tee --append $logfile";
      }
      else{
        $invoke_string.=">>$logfile";
      }
      CGLog($logfile,"COMMAND\n  $invoke_string",'append');
      system($invoke_string);
      CGLog($logfile,"ANNOTATION END on $project ".date(),'append');
      last if($command ne "build");
    }
    else{
      die "Command $command not found.\n".usage();
    }
  }
  return 0;
}

# returns a string to help redirect output, depending on the verbose setting
# parameter: settings variable
sub verbosity($){

}
sub date{
  use Date::Format;
  return time2str('%a %b %e %k:%M:%S',time())." (CG-Pipeline wrapper v$WRAPPER_VERSION, CG-Pipeline v$VERSION)";
}
# logs a message to a file and prints it at the same time
# parameter: filename
# parameter: string to print
# optional parameter: append
sub CGLog($$;$){
  my($filename,$str,$append)=@_;
  $str.="\n";
  if($append){
    open FILE,">>",$filename or warn("Cannot open log file $filename for writing.\n");
  }
  else{
    open FILE,">",$filename or warn("Cannot open log file $filename for writing.\n");
  }
  print FILE $str;
  print $str if($verbose>0);
  close FILE;
  return 1;
}

# returns a usage string
# parameter: v for verbose
sub usage($){
  my($option)=@_;
  my($script,$str);
  $option=lc($option);
  
  $script=fileparse $0;

  if($option eq 'v'){
    $str="\n\tusage: $script [build|create|assemble|predict|annotate] [-p project] -i target.sff [-r reference.fasta] [-t tag_prefix]\n
Commands:
  build create assemble predict annotate (see above)

Parameters:
  -h This help menu
  -p Project Name
  -i Input file
  -r Reference file
  -t Tag prefix
  -d Force denovo assembly
  -f Force create a project when the command create fails
  -v Set the level of verbosity. 0 for no stdout, 1 for some stdout, 2 for all stdout
examples:

$script build -i MyStrain.sff -r reference.fna
  Performs a complete genome build:
  1. Creates a project directory named MyStrain_Pipeline
  2. Assembles the sff input against the reference (or assembles de novo if no reference file is provided). Output is MyStrain_Pipeline/assembly.fasta.
  3. Runs prediction on assembly.fasta. Output is MyStrain_Pipeline/prediction.gb. Locus tags will be generated as MyStrain_0001, MyStrain_0002, etc. unless the -t option is given with an alternative tag prefix.
  4. Runs annotation on MyStrain_Pipeline/prediction.gb. Output data files are in MyStrain_Pipeline/annotation/.

$script create -p MyStrain
  Creates a directory named MyStrain containing subdirectories where project files will be generated.

$script assemble -p MyStrain -i sff-file [ -r reference ]
  Runs assembly in project MyStrain of sff-file using a reference in nucleotide fasta file if -r is specified, de novo if not. All messages are stored in MyStrain/log/assembly.txt

$script predict -p MyStrain [-i assembly-file]
  Runs prediction in project MyStrain against MyStrain/assembly.fasta, or an alternative file if specified. All messages are stored in MyStrain/log/prediction.txt. Output file is MyStrain/prediction.gb

$script annotate -p MyStrain [-i alt-prediction-file]
  Runs prediction in project MyStrain against MyStrain/prediction.gb, or an alternative file if specified. All messages are stored in MyStrain/log/annotation.log. Output files will appear in MyStrain/annotation/*.sql\n\n";
  }
  else{
    $str="\tusage: $script [build|create|assemble|predict|annotate] [-p project] -i target.sff [-r reference.fasta] [-t tag_prefix]
    type \'$script -h\' for more information.\n";
  }
  return $str;
}
